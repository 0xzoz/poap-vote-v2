<template>
  <div style="max-width: 400px; margin: 0 auto;">
    <q-form class="column content-stretch q-mb-xl">
      <!-- POLL TITLE AND DESCRIPTION -->
      <h5 class="section-header">
        Title and Description
      </h5>
      <!-- Poll title -->
      <base-input
        v-model="title"
        label="Title"
      />

      <!-- Poll description -->
      <base-input
        v-model="description"
        label="Description"
        type="textarea"
      />

      <!-- POLL OPTIONS -->
      <h5 class="section-header">
        Poll Options
      </h5>

      <!-- Options list -->
      <div
        v-for="(option, index) in poll_options"
        :key="index"
      >
        <base-input
          v-model="poll_options[index].contents"
          :label="`Option ${index + 1}`"
        />
      </div>

      <!-- Add new option -->
      <div class="text-left">
        <base-button
          color="primary"
          :dense="true"
          label="Add option"
          :flat="true"
          @click="addOption"
        />
      </div>

      <!-- VALID EVENTS -->
      <h5 class="section-header">
        Valid Events
      </h5>
      <div class="text-left">
        A user will be able to vote on this poll only if they hold a valid POAP
        token from at least one of the selected events
        <q-select
          v-model="valid_events"
          class="q-my-sm"
          filled
          label="Events"
          multiple
          :options="events"
          option-label="name"
        />
      </div>

      <!-- POLL END DATE/TIME -->
      <h5 class="section-header">
        End Date and Time
      </h5>
      <div class="text-left">
        Enter the polling end date and time, specified in 24-hour
        format using your local time zone
      </div>
      <div class="row justify-between">
        <!-- End date -->
        <q-input
          v-model="end_day"
          class="col-auto q-my-sm"
          filled
          label="End date"
          mask="date"
          placeholder="YYYY/MM/DD"
          style="max-width: 190px;"
          :rules="['date']"
        >
          <template v-slot:append>
            <q-icon
              name="fas fa-calendar-alt"
              class="cursor-pointer"
            >
              <q-popup-proxy
                ref="qDateProxy"
                transition-show="scale"
                transition-hide="scale"
              >
                <q-date
                  v-model="end_day"
                  @input="() => $refs.qDateProxy.hide()"
                />
              </q-popup-proxy>
            </q-icon>
          </template>
        </q-input>

        <!-- End time -->
        <q-input
          v-model="end_time"
          class="col-auto q-my-sm"
          filled
          label="End time"
          mask="time"
          placeholder="HH:MM"
          style="max-width: 190px;"
          :rules="['time']"
        >
          <template v-slot:append>
            <q-icon
              name="fas fa-clock"
              class="cursor-pointer"
            >
              <q-popup-proxy
                transition-show="scale"
                transition-hide="scale"
              >
                <q-time
                  v-model="end_time"
                  format24h
                />
              </q-popup-proxy>
            </q-icon>
          </template>
        </q-input>
      </div>

      <div>
        <base-button
          color="primary"
          :full-width="true"
          label="Create"
          @click="createPoll"
        />
      </div>
    </q-form>
  </div>
</template>

<script>
import { mapState } from 'vuex';
import eip712 from 'src/mixins/eip712';
import { date } from 'quasar';

export default {
  name: 'TheCreatePollForm',

  mixins: [eip712],

  data() {
    return {
      // Poll properties
      // id, fancyId, and startDate will be generated by the server
      title: undefined,
      description: undefined,
      end_day: undefined,
      end_time: undefined,
      valid_events: [],
      poll_options: [
        // start with two empty options
        { contents: undefined },
        { contents: undefined },
      ],
    };
  },

  computed: {
    ...mapState({
      userAddress: (state) => state.user.userAddress,
      events: (state) => state.poap.events,
    }),

    /**
     * @notice Takes the entered date and time provided by the user and
     * converts it into a unix timestamp (therefore this is in seconds)
     */
    end_date() {
      const [year, month, day] = this.end_day.split('/');
      const [hours, minutes] = this.end_time.split(':');
      const lastDay = date.buildDate({
        year, month, date: day, hours, minutes,
      });
      return parseInt(lastDay.getTime() / 1000, 10);
    },
  },

  mounted() {
    this.startDate = new Date();
  },

  methods: {
    addOption() {
      this.poll_options.push({ contents: undefined });
    },

    async createPoll() {
      // Define EIP-712 signature format for creating polls
      const dataFormat = [
        { name: 'title', type: 'string' },
        { name: 'polltaker_account', type: 'address' },
        { name: 'description', type: 'string' },
        { name: 'valid_event_ids', type: 'bytes32' },
        { name: 'poll_options', type: 'string' },
        { name: 'end_date', type: 'string' },
      ];

      // The actual data to be signed
      const pollData = {
        title: this.title,
        polltaker_account: this.userAddress,
        description: this.description,
        valid_event_ids: this.valid_events.map((event) => event.id),
        poll_options: this.poll_options,
        end_date: this.end_date,
      };

      // Format data and get user's signature
      const signature = await this.getSignature('Poll', dataFormat, pollData, this.userAddress);

      // Generate object to send to server
      const payload = {
        ...pollData,
        attestation: signature,
      };
      console.log('server payload ', payload);
    },
  },
};
</script>

<style lang="stylus" scoped>
.section-header {
  color: $secondary
  text-align: left
}
</style>
